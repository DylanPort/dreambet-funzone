// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://vjerwqqhcedemgfgfzbg.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZqZXJ3cXFoY2VkZW1nZmdmemJnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE0Mjg2NzIsImV4cCI6MjA1NzAwNDY3Mn0.zOcE-5pn_FEMYErg5up6BPsHwI3SBVPXAXoKb7ZJK20";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  global: {
    // Add rate limit handling with exponential backoff retry
    fetch: async (url, options) => {
      // Keep track of retry attempts
      let retries = 0;
      const maxRetries = 3;
      const baseDelay = 1000; // Start with 1 second delay

      while (retries <= maxRetries) {
        try {
          const response = await fetch(url, options);
          
          // If not rate limited, return the response
          if (response.status !== 429) {
            return response;
          }
          
          // If we reach here, we've been rate limited
          retries++;
          
          if (retries > maxRetries) {
            console.warn(`Supabase rate limit exceeded after ${maxRetries} retries`);
            return response; // Return the rate-limited response after max retries
          }
          
          // Calculate exponential backoff delay
          const delay = baseDelay * Math.pow(2, retries - 1);
          console.log(`Rate limited by Supabase. Retry ${retries}/${maxRetries} in ${delay}ms`);
          
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, delay));
          
        } catch (error) {
          console.error("Error in Supabase fetch:", error);
          return new Response(JSON.stringify({ error: "Network error" }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
      
      // This should not be reached due to the return in the loop, but TS wants it
      return new Response(JSON.stringify({ error: "Max retries exceeded" }), {
        status: 429,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
});

// Maintain these existing utility functions
// Add a function to explicitly check for the existence of tables
export const checkSupabaseTables = async () => {
  try {
    const { data, error } = await supabase.from('users').select('id').limit(1);
    if (error) {
      console.error('Error checking users table:', error);
      return false;
    }
    return true;
  } catch (error) {
    console.error('Exception checking tables:', error);
    return false;
  }
};

// More sophisticated rate limit detection with time-window tracking
let rateLimitDetectedAt: number | null = null;
const RATE_LIMIT_COOLDOWN = 60000; // 1 minute cooldown after detecting a rate limit

// Check if we're hitting rate limits for Supabase authentication
export const isAuthRateLimited = async () => {
  // If we detected a rate limit recently, assume we're still rate limited
  if (rateLimitDetectedAt && (Date.now() - rateLimitDetectedAt) < RATE_LIMIT_COOLDOWN) {
    console.warn('Still in rate limit cooldown period, waiting...');
    return true;
  }
  
  try {
    // Try a lightweight query that doesn't require auth
    const { error } = await supabase.from('tokens').select('count').limit(1);
    
    // If we get a rate limit error, update our detection timestamp
    if (error && (
      error.message.includes('rate limit') || 
      error.code === '429' || 
      (typeof error.code === 'string' && error.code === '429')
    )) {
      console.warn('Supabase API rate limit detected:', error);
      rateLimitDetectedAt = Date.now();
      return true;
    }
    
    // If we've gotten this far without a rate limit error, reset our detection timestamp
    rateLimitDetectedAt = null;
    return false;
  } catch (error) {
    console.error('Exception checking rate limits:', error);
    return false;
  }
};
